using System.Collections.Generic;
using System.Linq;
using System.Text;
using MarkdownData.SourceGeneration.Parser;

namespace MarkdownData.SourceGeneration.Emitter;

/// <summary>
/// Emits source code for MDF serialization.
/// </summary>
internal static class SerializerEmitter
{
    public static string EmitTypeInfo(TypeMetadata type)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(type.Namespace))
        {
            sb.AppendLine($"namespace {type.Namespace};");
            sb.AppendLine();
        }

        var className = $"{type.TypeName}MdfTypeInfo";

        sb.AppendLine($"public sealed class {className} : global::MarkdownData.MdfTypeInfo<{type.FullTypeName}>");
        sb.AppendLine("{");
        sb.AppendLine($"    public static {className} Instance {{ get; }} = new();");
        sb.AppendLine();
        sb.AppendLine($"    public override void Serialize(global::MarkdownData.MdfWriter writer, {type.FullTypeName} value)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (value == null) return;");
        sb.AppendLine();

        // Emit title (H1) if TitleProperty is set
        if (!string.IsNullOrEmpty(type.TitleProperty))
        {
            var titleProp = type.Properties.FirstOrDefault(p => p.Name == type.TitleProperty);
            if (titleProp != null)
            {
                sb.AppendLine($"        if (value.{titleProp.Name} != null)");
                sb.AppendLine($"            writer.WriteHeading(1, value.{titleProp.Name});");
                sb.AppendLine();
            }
        }

        // Emit description paragraph if DescriptionProperty is set
        if (!string.IsNullOrEmpty(type.DescriptionProperty))
        {
            var descProp = type.Properties.FirstOrDefault(p => p.Name == type.DescriptionProperty);
            if (descProp != null)
            {
                sb.AppendLine($"        if (value.{descProp.Name} != null)");
                sb.AppendLine($"            writer.WriteParagraph(value.{descProp.Name});");
                sb.AppendLine();
            }
        }

        EmitPropertySerializations(sb, type.Properties, "value", 2);

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    public static string EmitContext(ContextMetadata context)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(context.Namespace))
        {
            sb.AppendLine($"namespace {context.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {context.ClassName}");
        sb.AppendLine("{");

        // Static Default property
        sb.AppendLine($"    public static {context.ClassName} Default {{ get; }} = new();");
        sb.AppendLine();

        // Type info properties for each type
        foreach (var type in context.Types)
        {
            var typeInfoClass = GetTypeInfoClassName(type);
            sb.AppendLine($"    public {typeInfoClass} {type.TypeName} {{ get; }} = {typeInfoClass}.Instance;");
        }

        sb.AppendLine();

        // GetTypeInfo<T> implementation
        sb.AppendLine("    public override global::MarkdownData.MdfTypeInfo<T>? GetTypeInfo<T>()");
        sb.AppendLine("    {");

        foreach (var type in context.Types)
        {
            var typeInfoClass = GetTypeInfoClassName(type);
            sb.AppendLine($"        if (typeof(T) == typeof({type.FullTypeName}))");
            sb.AppendLine($"            return (global::MarkdownData.MdfTypeInfo<T>)(object){typeInfoClass}.Instance;");
        }

        sb.AppendLine("        return null;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GetTypeInfoClassName(TypeMetadata type)
    {
        if (string.IsNullOrEmpty(type.Namespace))
            return $"global::{type.TypeName}MdfTypeInfo";
        return $"global::{type.Namespace}.{type.TypeName}MdfTypeInfo";
    }

    private static void EmitPropertySerializations(
        StringBuilder sb,
        IReadOnlyList<PropertyMetadata> properties,
        string valueExpr,
        int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);

        foreach (var prop in properties)
        {
            if (prop.IsIgnored)
                continue;

            var propAccess = $"{valueExpr}.{prop.Name}";

            if (prop.IsSection)
            {
                var sectionName = prop.SectionName ?? prop.MdfName;

                if (prop.Kind == PropertyKind.ComplexArray && prop.ElementProperties != null)
                {
                    sb.AppendLine($"{indent}if ({propAccess} != null && {propAccess}.Count > 0)");
                    sb.AppendLine($"{indent}{{");
                    sb.AppendLine($"{indent}    writer.WriteHeading({prop.SectionLevel}, \"{EscapeString(sectionName)}\");");
                    EmitTableSerialization(sb, prop, propAccess, indentLevel + 1);
                    sb.AppendLine($"{indent}}}");
                }
                else if (prop.Kind == PropertyKind.NestedObject && prop.ElementProperties != null)
                {
                    sb.AppendLine($"{indent}if ({propAccess} != null)");
                    sb.AppendLine($"{indent}{{");
                    sb.AppendLine($"{indent}    writer.WriteHeading({prop.SectionLevel}, \"{EscapeString(sectionName)}\");");
                    EmitPropertySerializations(sb, prop.ElementProperties, propAccess, indentLevel + 1);
                    sb.AppendLine($"{indent}}}");
                }
                else
                {
                    // For other types, just write the heading unconditionally
                    sb.AppendLine($"{indent}writer.WriteHeading({prop.SectionLevel}, \"{EscapeString(sectionName)}\");");
                }
                continue;
            }

            switch (prop.Kind)
            {
                case PropertyKind.String:
                    sb.AppendLine($"{indent}if ({propAccess} != null)");
                    sb.AppendLine($"{indent}    writer.WriteField(\"{EscapeString(prop.MdfName)}\", {propAccess});");
                    break;

                case PropertyKind.Boolean:
                    sb.AppendLine($"{indent}writer.WriteField(\"{EscapeString(prop.MdfName)}\", {propAccess});");
                    break;

                case PropertyKind.Int32:
                case PropertyKind.Int64:
                case PropertyKind.Double:
                case PropertyKind.Decimal:
                    sb.AppendLine($"{indent}writer.WriteField(\"{EscapeString(prop.MdfName)}\", {propAccess});");
                    break;

                case PropertyKind.DateTime:
                case PropertyKind.DateTimeOffset:
                    sb.AppendLine($"{indent}writer.WriteField(\"{EscapeString(prop.MdfName)}\", {propAccess});");
                    break;

                case PropertyKind.StringArray:
                    sb.AppendLine($"{indent}if ({propAccess} != null)");
                    sb.AppendLine($"{indent}    writer.WriteArray(\"{EscapeString(prop.MdfName)}\", {propAccess});");
                    break;

                case PropertyKind.ComplexArray:
                    if (prop.ElementProperties != null && prop.ElementProperties.Count > 0)
                    {
                        sb.AppendLine($"{indent}if ({propAccess} != null && {propAccess}.Any())");
                        sb.AppendLine($"{indent}{{");
                        sb.AppendLine($"{indent}    writer.WriteHeading(2, \"{EscapeString(prop.MdfName)}\");");
                        EmitTableSerialization(sb, prop, propAccess, indentLevel + 1);
                        sb.AppendLine($"{indent}}}");
                    }
                    break;

                case PropertyKind.NestedObject:
                    if (prop.ElementProperties != null && prop.ElementProperties.Count > 0)
                    {
                        sb.AppendLine($"{indent}if ({propAccess} != null)");
                        sb.AppendLine($"{indent}{{");
                        sb.AppendLine($"{indent}    writer.WriteHeading(2, \"{EscapeString(prop.MdfName)}\");");
                        EmitPropertySerializations(sb, prop.ElementProperties, propAccess, indentLevel + 1);
                        sb.AppendLine($"{indent}}}");
                    }
                    break;

                case PropertyKind.Other:
                    // Try to call ToString() for unknown types
                    sb.AppendLine($"{indent}if ({propAccess} != null)");
                    sb.AppendLine($"{indent}    writer.WriteField(\"{EscapeString(prop.MdfName)}\", {propAccess}.ToString());");
                    break;
            }
        }
    }

    private static void EmitTableSerialization(
        StringBuilder sb,
        PropertyMetadata prop,
        string propAccess,
        int indentLevel)
    {
        if (prop.ElementProperties == null || prop.ElementProperties.Count == 0)
            return;

        var indent = new string(' ', indentLevel * 4);
        var visibleProps = prop.ElementProperties.Where(p => !p.IsIgnored).ToList();

        // Build header array
        var headers = string.Join(", ", visibleProps.Select(p => $"\"{EscapeString(p.MdfName)}\""));
        sb.AppendLine($"{indent}writer.WriteTableStart({headers});");

        sb.AppendLine($"{indent}foreach (var item in {propAccess})");
        sb.AppendLine($"{indent}{{");

        // Build row values
        var values = new List<string>();
        foreach (var elemProp in visibleProps)
        {
            var value = GetTableCellValue(elemProp, "item");
            values.Add(value);
        }

        sb.AppendLine($"{indent}    writer.WriteTableRow({string.Join(", ", values)});");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine($"{indent}writer.WriteTableEnd();");
    }

    private static string GetTableCellValue(PropertyMetadata prop, string itemExpr)
    {
        var propAccess = $"{itemExpr}.{prop.Name}";

        return prop.Kind switch
        {
            PropertyKind.Boolean => $"{propAccess} ? \"yes\" : \"no\"",
            PropertyKind.String => $"{propAccess} ?? \"\"",
            PropertyKind.Int32 or PropertyKind.Int64 or PropertyKind.Double or PropertyKind.Decimal
                => $"{propAccess}.ToString(System.Globalization.CultureInfo.InvariantCulture)",
            PropertyKind.DateTime or PropertyKind.DateTimeOffset
                => $"{propAccess}.ToString(\"O\", System.Globalization.CultureInfo.InvariantCulture)",
            _ => $"{propAccess}?.ToString() ?? \"\""
        };
    }

    private static string EscapeString(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
}
